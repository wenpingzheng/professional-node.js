#float to dec

http://blog.163.com/yql_bl/blog/static/847851692008112013117685/


例一：
已知：double类型38414.4。
求：其对应的二进制表示。
分析：double类型共计64位，折合8字节。由最高到最低位分别是第63、62、61、……、0位：
    最高位63位是符号位，1表示该数为负，0表示该数为正；
    62-52位，一共11位是指数位；
    51-0位，一共52位是尾数位。

     步骤：按照IEEE浮点数表示法，下面先把38414.4转换为十六进制数。
     把整数部和小数部分开处理:整数部直接化十六进制：960E。小数的处理:
     
0.4=0.5*0+0.25*1+0.125*1+0.0625*0+……
     实际上这永远算不完！这就是著名的浮点数精度问题。所以直到加上前面的整数部分算够53位就行了。隐藏位技术：最高位的1不写入内存（最终保留下来的还是52位）。
    如果你够耐心，手工算到53位那么因该是：38414.4(10)=1001011000001110.0110011001100110011001100110011001100(2)
科学记数法为：1.001011000001110 0110011001100110011001100110011001100，右移了15位，所以指数为15。或者可以如下理解：
1.001011000001110 0110011001100110011001100110011001100×2^15
     于是来看阶码，按IEEE标准一共11位，可以表示范围是-1024 ~ 1023。因为指数可以为负，为了便于计算，规定都先加上1023(2^10-1)，在这里，阶码：15+1023=1038。二进制表示为：100 00001110；
    符号位：因为38414.4为正对应 为0；
    合在一起（注：尾数二进制最高位的1不要）：
01000000 11100010 11000001 110 01100  11001100  11001100  11001100  11001100




例二：

已知：整数3490593(16进制表示为0x354321)。
求：其对应的浮点数3490593.0的二进制表示。 
解法如下：
先求出整数3490593的二进制表示：
 H:    3     5    4    3    2     1   （十六进制表示）
 B:   0011  0101 0100 0011 0010  0001 （二进制表示）
        │←─────  21────→│
 
即： 
               1.1010101000011001000012×221
可见，从左算起第一个1后有21位，我们将这21为作为浮点数的小数表示，单精度浮点数float由符号位1位，指数域位k=8位，小数域位(尾数)n=23位构成，因此对上面得到的21位小数位我们还需要补上2个0，得到浮点数的小数域表示为：
         1 0101 0100 0011 0010 0001 00
 
float类型的偏置量Bias=2k-1-1=28-1-1=127，但还要补上刚才因为右移作为小数部分的21位，因此偏置量为127+21=148，就是IEEE浮点数表示标准：
                          V = (-1)s×M×2E
                    E = e-Bias
中的e，此前计算Bias=127，刚好验证了E=148-127=21。
 
将148转为二进制表示为10010100，加上符号位0，最后得到二进制浮点数表示1001010010101010000110010000100，其16进制表示为：
 H:     4        A       5          5         0         C         8        4  
 B:  0100   1010   0101    0101   0000   1100  1000   0100
                    |←────      21        ─────→   |
     1|←─8   ─→||←─────       23       ─────→ |
 
这就是浮点数3490593.0(0x4A550C84)的二进制表示。




例三：


